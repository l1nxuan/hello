# Project Overview

This is an embedded firmware project targeting the **STM32F429ZI** microcontroller (ARM Cortex-M4 with FPU) running at 168 MHz. It features a GUI application using the ThreadX RTOS and LVGL graphics library, designed for the Armfly V6 development board.

## Hardware Platform

| Component | Specification |
|-----------|---------------|
| MCU | STM32F429ZI (ARM Cortex-M4, 180 MHz max, with FPU) |
| Board | Armfly V6 development board |
| Display | 800x480 LCD with OTD9960/OTA7001 controller, connected via LTDC |
| External Memory | ISSI IS42S32400F-6TLI SDRAM (16MB total, 4 banks of 4MB each) |
| Touch Controller | STMPE811 (capacitive/resistive touch) |
| Debugger | ST-Link V2 (via OpenOCD) |

## Technology Stack

| Component | Purpose | Version/Notes |
|-----------|---------|---------------|
| ThreadX | Real-time operating system | Azure RTOS, v6.x |
| LVGL | Graphics library | v9.5.0 |
| EEZ Studio | UI design tool | Generates LVGL UI code |
| STM32 HAL | Hardware abstraction layer | STM32F4xx HAL |
| CMSIS | ARM Cortex-M support | Core headers |
| SEGGER RTT | Real-time debug logging | v8.56a |
| CMake | Build system | 3.21+ |
| Ninja | Build generator | Required |
| arm-none-eabi-gcc | Cross-compiler | 14.3 rel1 recommended |

## Project Structure

```
├── app/                          # Application layer
│   ├── tx_application_define.c   # ThreadX initialization & thread creation
│   ├── tx_application_define.h   # Thread configuration (stack sizes, priorities)
│   ├── sample/                   # Sample thread (ADC/DAC data processing)
│   │   ├── sample.c              # Sample thread implementation
│   │   └── sample.h
│   ├── display/                  # Display/GUI related code
│   │   ├── display_1.c           # LVGL display thread implementation
│   │   ├── display_1.h           # Display thread public API
│   │   ├── lv_log_print_cb.c     # LVGL log callback via RTT
│   │   ├── ui_data_binding.c     # UI data binding logic
│   │   └── ui_data_binding.h
│   ├── eez_studio/               # UI code generated by EEZ Studio
│   │   └── src/
│   │       ├── ui.c              # Main UI initialization
│   │       ├── ui.h
│   │       ├── screens.c         # Screen definitions
│   │       ├── screens.h
│   │       ├── actions.c         # UI action handlers
│   │       ├── actions.h
│   │       ├── images.c          # Image resources
│   │       ├── images.h
│   │       ├── styles.c          # UI styles
│   │       ├── styles.h
│   │       ├── fonts.h
│   │       ├── vars.h
│   │       └── structs.h
│   ├── demo_waveform.c           # Waveform generator for demo
│   └── demo_waveform.h
├── boards/                       # Board-specific code
│   └── armfly_v6/                # Armfly V6 board support
│       ├── mcu/                  # MCU peripheral drivers
│       │   ├── adc.c             # ADC initialization
│       │   ├── adc.h
│       │   ├── dac.c             # DAC initialization
│       │   ├── dac.h
│       │   ├── dma.c             # DMA controller
│       │   ├── fmc.c             # Flexible memory controller (FMC/FSMC)
│       │   ├── hal_assert.c      # HAL assertion handler
│       │   ├── hal_timebase.c    # HAL timebase (TIM6)
│       │   ├── i2c.c             # I2C initialization
│       │   ├── i2c.h
│       │   ├── ltdc.c            # LCD-TFT display controller
│       │   ├── nvic.c            # NVIC configuration
│       │   ├── tim.c             # Timer configurations
│       │   └── tim.h
│       ├── eeprom.c              # EEPROM interface
│       ├── eeprom.h
│       ├── key.c                 # Key/button input handling
│       ├── key.h
│       ├── latch_io.c            # Latched I/O control
│       ├── latch_io.h
│       ├── lcd.c                 # LCD controller initialization
│       ├── lcd.h                 # LCD API and framebuffer addresses
│       ├── led.c                 # LED control
│       ├── led.h
│       ├── sdram.c               # SDRAM controller initialization
│       ├── sdram.h               # SDRAM memory map definitions
│       ├── touch.c               # Touch controller interface
│       └── touch.h
├── drivers/                      # Low-level drivers
│   ├── CMSIS/Core/Include/       # ARM CMSIS headers
│   ├── Device/ST/STM32F4xx/      # STM32F4 device headers & startup
│   │   ├── Include/              # Device headers (stm32f429xx.h, system_stm32f4xx.h)
│   │   ├── Source/gcc/           # GCC startup assembly
│   │   │   └── startup_stm32f429xx.s
│   │   ├── Source/system_stm32f4xx.c
│   │   └── STM32F429XX_FLASH.ld  # Linker script
│   ├── STM32F4xx_HAL_Driver/     # STM32 HAL library source
│   │   ├── Inc/                  # HAL headers
│   │   └── Src/                  # HAL source files
│   └── STMPE811/                 # Touch controller driver
│       ├── stmpe811.c
│       ├── stmpe811.h
│       ├── stmpe811_reg.c
│       ├── stmpe811_reg.h
│       └── LICENSE.md
├── include/                      # Global configuration headers
│   ├── main.h                    # Main header (for lv_st_ltdc.c)
│   ├── stm32f4xx_hal_conf.h      # HAL configuration (enabled modules)
│   ├── tx_user.h                 # ThreadX user configuration
│   ├── lv_conf.h                 # LVGL configuration
│   ├── gx_user.h                 # GUIX user configuration (unused)
│   ├── swtimer.def               # Software timer definitions
│   ├── utils.h                   # Utility macros (PRINTF, MIN/MAX/CLAMP)
│   └── stmpe811_conf.h           # STMPE811 touch controller config
├── init/                         # Startup code
│   ├── main.c                    # Entry point, clock config, RTOS start
│   ├── syscalls.c                # System call stubs for newlib
│   └── sysmem.c                  # Memory management stubs
├── lib/                          # Third-party libraries
│   ├── threadx/                  # Azure RTOS ThreadX
│   │   ├── common/               # Core ThreadX source
│   │   └── ports_arch/ARMv7-M/gnu/   # Cortex-M4 GCC port
│   ├── lvgl/                     # LVGL graphics library v9.5.0
│   ├── guix/                     # Azure RTOS GUIX (not currently used)
│   ├── RTT/                      # SEGGER RTT logging
│   ├── swtimer/                  # Software timer utility
│   └── SystemView/               # SEGGER SystemView (unused)
├── cmake/
│   └── arm-none-eabi.cmake       # CMake toolchain file
├── openocd/                      # OpenOCD configuration
│   ├── interface/stlink.cfg      # ST-Link debugger interface
│   └── target/stm32f4x.cfg       # STM32F4 target configuration
├── svd/                          # SVD file for debugging
│   └── STM32F4_svd_V2.0/STM32F429.svd
├── .vscode/                      # VS Code configuration
│   ├── launch.json               # Debug configuration (cortex-debug + OpenOCD)
│   ├── tasks.json                # Build/flash tasks
│   └── settings.json             # Editor settings
├── build/                        # Build output directory
│   ├── Debug/                    # Debug build output
│   └── Release/                  # Release build output
├── CMakeLists.txt                # Main CMake configuration
└── CMakePresets.json             # CMake build presets
```

## Build Instructions

### Prerequisites

- CMake 3.21 or higher
- Ninja build system
- GNU Arm Embedded Toolchain (arm-none-eabi-gcc)
- OpenOCD (for flashing and debugging)

### Configure and Build

```bash
# Debug build (recommended for development)
cmake --preset Debug
cmake --build build/Debug

# Release build (optimized)
cmake --preset Release
cmake --build build/Release
```

### Output Files

After a successful build, the following files are generated in `build/Debug/` or `build/Release/`:

| File | Description |
|------|-------------|
| `hello.elf` | ELF executable with debug symbols |
| `hello.map` | Linker map file (shows memory layout) |
| `compile_commands.json` | For clangd/IDE IntelliSense |

### Flash to Target

**Using VS Code tasks (recommended):**
- Press `Ctrl+Shift+P` → "Tasks: Run Task" → "Flash with OpenOCD"

**Or manually via command line:**
```bash
openocd -s openocd \
    -f interface/stlink.cfg \
    -f target/stm32f4x.cfg \
    -c "program build/Debug/hello.elf verify reset exit"
```

## Debugging

### VS Code Configuration

The project includes VS Code configurations for debugging in `.vscode/`:

1. Open the project in VS Code
2. Press `F5` to start debugging with OpenOCD
3. The debugger will:
   - Start OpenOCD with ST-Link interface
   - Connect to the STM32F4 target
   - Enable SEGGER RTT for console output
   - Enable live watch for real-time variable inspection
   - Run to `main()` and break

### SEGGER RTT Output

Debug output is sent via SEGGER RTT (Real-Time Transfer):
- RTT channel 0 is used for console output
- `PRINTF()` macro sends formatted output to RTT (only in DEBUG builds)
- Output appears in VS Code debug console when using cortex-debug

### clangd Configuration

The project uses clangd for IntelliSense:
- Configuration in `.clangd` file
- Compilation database generated at `build/Debug/compile_commands.json`
- VS Code settings in `.vscode/settings.json` configure clangd arguments

## Clock Configuration

| Clock | Frequency | Source |
|-------|-----------|--------|
| System Clock (SYSCLK) | 168 MHz | PLL (HSE 8MHz × 42 / 2) |
| AHB (HCLK) | 168 MHz | SYSCLK |
| APB1 (PCLK1) | 42 MHz | HCLK / 4 |
| APB2 (PCLK2) | 84 MHz | HCLK / 2 |
| LCD-TFT Clock | 30 MHz | PLLSAI (120 / 2 / 2) |
| SDRAM Clock | 84 MHz | HCLK / 2 |

## Memory Layout

| Region | Address | Size | Usage |
|--------|---------|------|-------|
| Flash | 0x0800_0000 | 2 MB | Program code and constants |
| SRAM | 0x2000_0000 | 192 KB | Data, stack, heap |
| CCM RAM | 0x1000_0000 | 64 KB | Thread stacks (performance) |
| SDRAM Bank 1 | 0xC000_0000 | 4 MB | LCD Framebuffer (layer 1) |
| SDRAM Bank 2 | 0xC040_0000 | 4 MB | LVGL draw buffers |
| SDRAM Banks 3-4 | 0xC080_0000 | 8 MB | Available for application |

## ThreadX Configuration

Key settings from `include/tx_user.h`:

| Parameter | Value | Description |
|-----------|-------|-------------|
| TX_TIMER_TICKS_PER_SECOND | 1000 | 1ms tick resolution |
| TX_TIMER_THREAD_PRIORITY | 1 | Highest priority for timer thread |
| TX_DISABLE_ERROR_CHECKING | defined | Disable for performance |
| TX_ENABLE_STACK_CHECKING | defined | Enable stack overflow checks |
| TX_DISABLE_REDUNDANT_CLEARING | defined | Disable redundant clearing |

### Application Threads

| Thread | Stack Size | Priority | Purpose |
|--------|------------|----------|---------|
| Display 1 Thread | 4 KB | 30 | LVGL timer handler and rendering |
| Sample Thread | 4 KB | 0 | ADC/DAC data processing (waveform acquisition) |
| Timer Thread | (default) | 1 | ThreadX internal timer services |

All thread stacks are placed in CCM RAM (fast access) using `__attribute__((section(".ccmram")))`.

### Thread Communication

The Sample thread waits on a semaphore (`convcplt_sem`) that is signaled from ADC DMA completion callbacks. Data is shared between the Sample thread and Display thread via the `refresh_events` flag and `chart_1_serie_1_buffer` array.

## LVGL Configuration

Key settings from `include/lv_conf.h`:

| Parameter | Value | Description |
|-----------|-------|-------------|
| LV_COLOR_DEPTH | 16 | RGB565 color format |
| LV_USE_OS | LV_OS_THREADX | Use ThreadX for LVGL threading |
| LV_DEF_REFR_PERIOD | 33 ms | ~30 FPS refresh rate |
| LV_MEM_SIZE | 32 KB | LVGL internal heap |
| LV_USE_DRAW_DMA2D | 1 | Enable STM32 DMA2D acceleration |
| LV_LOG_LEVEL | LV_LOG_LEVEL_TRACE | Verbose logging |
| LV_USE_DRAW_SW | 1 | Software renderer enabled |
| LV_DRAW_SW_DRAW_UNIT_CNT | 1 | Single draw unit (no parallel rendering) |
| LV_THEME_DEFAULT_DARK | 1 | Dark theme by default |
| LV_FONT_MONTSERRAT_14 | 1 | Default font enabled |

### LVGL Integration

- Display driver: `lv_st_ltdc_create_direct()` using STM32 LTDC hardware
- Tick source: `tx_time_get()` (ThreadX tick count)
- Sleep function: `lv_sleep_ms()` maps to `tx_thread_sleep()`
- Log output: Custom callback `lv_log_printf_rtt()` via SEGGER RTT
- Double-buffered direct mode with framebuffers in SDRAM

## EEZ Studio UI Integration

The project uses EEZ Studio to design the UI visually. The generated code is in `app/eez_studio/src/`:

- `ui_init()` - Initialize all screens and widgets
- `ui_tick()` - Update UI state (called periodically)
- `loadScreen()` - Switch between screens
- `actions.c/h` - Event handlers for UI interactions
- `screens.c/h` - Screen definitions and object references

### UI Data Binding

The `ui_data_binding.c` module connects UI elements to application data:
- Update widget values from backend data
- Handle user input and update backend state
- Typically called during screen transitions or timer callbacks

## Code Style Guidelines

The project uses the following code style (defined in `.clang-format`):

| Aspect | Setting |
|--------|---------|
| Base style | WebKit |
| Indentation | 4 spaces |
| Line endings | LF (see `.editorconfig`) |
| Macro alignment | Align consecutive macros across empty lines and comments |
| Include sorting | Disabled (`SortIncludes: Never`) |

### Naming Conventions

| Element | Convention | Example |
|---------|------------|---------|
| Files | lowercase_with_underscores | `display_1.c`, `tx_user.h` |
| Functions | lowercase_with_underscores | `display_1_thread_create()` |
| Macros/Constants | UPPERCASE_WITH_UNDERSCORES | `DISPLAY_1_THREAD_STACK_SIZE` |
| Types | PascalCase or lowercase_with_underscores_t | `TX_THREAD`, `lv_display_t` |
| Global variables | Prefix with module name when appropriate | `display_1_thread`, `hsdram1` |
| Thread stacks | `thread_name_stack` | `display_1_thread_stack` |

### Comments

- Use `//` for single-line comments
- Use `/* */` for multi-line comments
- Document public APIs in header files
- Explain non-obvious implementation details in source files

## Safety and Error Handling

### Assertions

The project uses two assertion mechanisms:

1. **Custom PRINTF macro** (`include/utils.h`):
   ```c
   PRINTF("message", INF0);   // Info message (green in RTT console)
   PRINTF("message", ERR0R);  // Error message (red in RTT console)
   ```
   Note: Only active in DEBUG builds.

2. **HAL assert_param** (STM32 HAL):
   ```c
   assert_param(IS_FUNCTION_PARAM(x));  // Parameter validation
   ```
   Enabled via `USE_FULL_ASSERT` in `stm32f4xx_hal_conf.h`.

### Stack Protection

- ThreadX stack filling is enabled (fills with 0xEF pattern)
- Stack checking is enabled in DEBUG builds (`TX_ENABLE_STACK_CHECKING`)
- Thread stacks are placed in CCM RAM for fast access

## Interrupt Priorities

| Interrupt | Priority | Notes |
|-----------|----------|-------|
| PendSV | 255 (lowest) | ThreadX context switch |
| SysTick | 64 | ThreadX timer tick |
| LTDC | 1 | Display controller (line interrupt) |

## HAL Module Configuration

Enabled HAL modules (from `stm32f4xx_hal_conf.h`):

- HAL_ADC_MODULE_ENABLED
- HAL_DAC_MODULE_ENABLED
- HAL_DMA_MODULE_ENABLED
- HAL_DMA2D_MODULE_ENABLED
- HAL_FLASH_MODULE_ENABLED
- HAL_GPIO_MODULE_ENABLED
- HAL_EXTI_MODULE_ENABLED
- HAL_I2C_MODULE_ENABLED
- HAL_LTDC_MODULE_ENABLED
- HAL_PWR_MODULE_ENABLED
- HAL_QSPI_MODULE_ENABLED
- HAL_RCC_MODULE_ENABLED
- HAL_SDRAM_MODULE_ENABLED
- HAL_SPI_MODULE_ENABLED
- HAL_SRAM_MODULE_ENABLED
- HAL_TIM_MODULE_ENABLED
- HAL_UART_MODULE_ENABLED
- HAL_USART_MODULE_ENABLED

Note: `USE_HAL_LTDC_REGISTER_CALLBACKS` is set to 1U to enable LTDC callback registration.

## Development Workflow

### Adding a New HAL Module

1. Enable the module in `include/stm32f4xx_hal_conf.h`
2. Add the source file to `CMakeLists.txt` in the `target_sources` section
3. Include the corresponding header in files that use the module

### Adding a New ThreadX Thread

1. Define stack size and priority in `app/tx_application_define.h`
2. Create thread entry function and thread create function in a new module
3. Call the create function in `tx_application_define.c`
4. Place thread and stack in CCM RAM if performance-critical:
   ```c
   TX_THREAD my_thread __attribute__((section(".ccmram")));
   UCHAR my_thread_stack[MY_THREAD_STACK_SIZE] __attribute__((section(".ccmram")));
   ```

### Modifying the UI with EEZ Studio

1. Open the project in EEZ Studio (open `app/eez_studio/demo.eez-project`)
2. Modify screens, add widgets, or change styles
3. Export/generate code to `app/eez_studio/src/`
4. Update `ui_data_binding.c` to connect new widgets to data
5. Add event handlers in `actions.c` if needed

### Adding LVGL Widgets Manually

1. Widget code can be added in `app/display/`
2. Include LVGL headers: `#include "lvgl.h"`
3. Call widget creation functions from `display_1_thread_entry()` or related code

### Debugging with RTT

1. Use `PRINTF("message", INF0)` for info messages
2. Use `PRINTF("message", ERR0R)` for error messages
3. RTT output requires DEBUG build (`cmake --preset Debug`)
4. View output in VS Code debug console when using cortex-debug

## Troubleshooting

### Build Issues

- Ensure `arm-none-eabi-gcc` is in PATH
- Check CMake version (3.21+ required)
- Verify Ninja is installed
- Check that toolchain file is found: `cmake/arm-none-eabi.cmake`

### Debug Connection Issues

- Check ST-Link connection and power
- Ensure OpenOCD can find the interface/target configs
- Try lowering SWD clock frequency if unreliable
- Verify the SVD file path in `.vscode/launch.json`

### Display Issues

- Verify SDRAM initialization passes self-test (call `sdram_testcase()` in DEBUG)
- Check LTDC clock configuration (30 MHz target)
- Ensure framebuffers are in SDRAM Bank 1/2
- Verify LCD backlight is on (`lcd_backlight_on()`)

### LVGL Performance

- Check that DMA2D is enabled (`LV_USE_DRAW_DMA2D 1`)
- Verify CCM RAM is used for thread stacks
- Monitor refresh period (`LV_DEF_REFR_PERIOD`)
- Use RTT logs to check for rendering issues

### Touch Issues

- Verify STMPE811 touch controller initialization
- Check I2C communication with touch controller
- Verify touch interrupt GPIO configuration

## License Notes

| Component | License |
|-----------|---------|
| ThreadX | MIT License (Azure RTOS) |
| LVGL | MIT License |
| STM32 HAL | BSD-3-Clause |
| SEGGER RTT | BSD-style (see LICENSE.txt) |
| CMSIS | Apache-2.0 |
| EEZ Studio | GPL v3 (UI generator) |
| STMPE811 | BSD-3-Clause |
